(defpackage :ita
    (:use :cl)
  (:export :run-collect))
(in-package :ita)
(declaim (optimize (debug 0) (safety 0)(space 0) (compilation-speed 0) (speed 3)))
(defun map-n-permute-helper (l n f to-be-added acc)
  (if (and (funcall f to-be-added acc) (> n 0))
      (progn
	(setf acc (append to-be-added acc))
	(loop for i in l 
	      do (map-n-permute-helper l (1- n) f  i acc)))))
(defun map-n-permute (l n f)
  (map-n-permute-helper l n f nil nil))
(defun is-peer (comp1 comp2)
  (let ((ind (string<  #0=(cadr comp1) (cadr comp2))))
    (if (equalp ind (length #0#)) ind nil)))
(defun integer-comparator (l1 l2)
  (flet ((to-string (l) (apply #'concatenate (cons 'string (mapcar #'cadr l)))))
    (string< (to-string l1) (to-string l2))))
(defun split-list (l marker)
  (let ((before nil) (cur (car l)) (after (cdr l)))
    (loop while (and cur (not (equalp cur marker)))
      do (progn 
	   (push cur before)
	   (setf cur (pop after)))
      finally (return (values (nreverse before) after cur)))))
(defun number-of-characters (l)
  (apply #'+ (mapcar #'caddr l)))
(defun is-valid (to-be-added l)
  (labels ((is-valid-number-upto-9 (l)
	     (if l (if (cdr l) nil
		       (if (> (car l) 9) nil t))
		 nil))
	   (is-valid-number-upto-99 (l)
	     (if l 
		 (if (cdr l)
		     (if (cddr l)
			 nil
			 (and (< (cadr l) 10) (> (car l) 19) (< (car l) 100)))
		     (< (car l) 100))
		 nil))
	   (is-valid-number-upto-999 (l)
	     (if l (multiple-value-bind (before after has-marker) (split-list l 100)
		     (if has-marker
			 (progn
			   (if (not (is-valid-number-upto-9 before)) (return-from is-valid-number-upto-999 nil)) 
			   (if after
			       (return-from is-valid-number-upto-999 (is-valid-number-upto-99 after))))
			 (return-from is-valid-number-upto-999 (is-valid-number-upto-99 before)))
		     t)
		 nil)))
    (if l
	(progn 
	  (if (and (eq (cadddr (car to-be-added)) :should-not-come-after-comps-having-peers)
		   (eq (cadddr (car l)) :has-peers))
	      (return-from is-valid nil))
	  (setf to-be-added (mapcar #'car to-be-added))
	  (setf l (mapcar #'car l))
	  (let ((tmpl l) (to-be-tested to-be-added)
		(powers-of-thousand (if (eq (mod (car to-be-added) 1000) 0)
					(car to-be-added) nil)))
	    (if powers-of-thousand 
		(progn
		  (if (>= powers-of-thousand (if #6=(loop for i in l
							  when (equalp (mod i 1000) 0)
							  do (return i)) #6# 1000000000))
		      (return-from is-valid nil))
		  (pop to-be-tested)))
	    (setf to-be-tested (nreverse to-be-tested))
	    (loop while (and tmpl (not (eq (mod (car tmpl) 1000) 0)))
	      do (push (pop tmpl) to-be-tested))
	    (return-from is-valid (if (is-valid-number-upto-999 to-be-tested) to-be-tested nil))))
	(if to-be-added (let ((tmpl (mapcar #'car to-be-added)))
			  (if (equalp (mod (car tmpl) 1000) 0) 
			      (return-from is-valid (is-valid-number-upto-999 (nreverse (cdr tmpl))))
			      (return-from is-valid (is-valid-number-upto-999 (nreverse tmpl)))))
	    t))))
(defun comps-to-integer (l)
  (labels ((comps-to-integer-helper (l)
	     (cond 
	       ((find 1000000 l) (multiple-value-bind (before after) (split-list l 1000000)
				   (+ (* (comps-to-integer-helper before) 1000000) (comps-to-integer-helper after))))
	       ((find 1000 l) (multiple-value-bind (before after) (split-list l 1000)
				(+ (* (comps-to-integer-helper before) 1000) (comps-to-integer-helper after))))
	       ((find 100 l) (multiple-value-bind (before after) (split-list l 100)
			       (+ (* (comps-to-integer-helper before) 100) (comps-to-integer-helper after))))
	       (t (apply #'+ l)))))
    (comps-to-integer-helper (mapcar #'car l))))
(let* ((number-word-list '((1 . "one") (2 . "two") (3 . "three") (4 ."four") 
			   (5 . "five") (6 .  "six") (7 . "seven") (8 . "eight") (9 . "nine") 
			   (10 . "ten") (11 . "eleven") (12 . "twelve") (13 . "thirteen") (14 . "fourteen") 
			   (15 . "fifteen") (16 . "sixteen") (17 . "seventeen") (18 . "eighteen") (19 . "nineteen")
			   (20 . "twenty") (30 . "thirty") (40 . "forty") (50 . "fifty") 
			   (60 . "sixty") (70 . "seventy") (80 . "eighty") (90 . "ninety") (100 . "hundred") 
			   (1000 . "thousand") (1000000 . "million")))
       (sorted-comps (mapcar (lambda (x) (list (car x) #2=(cdr x) (length #2#)))
			     (sort (copy-seq number-word-list) #'string< :key #'cdr)))
       (should-not-come-after-comps-having-peers '(:should-not-come-after-comps-having-peers))
       (valid-combinators-for-comps-with-peers (mapcar (lambda (x) (setf (cdddr x) should-not-come-after-comps-having-peers)
							       x) 
						       (loop for i in sorted-comps
							     when (eq (mod (car i) 100) 0)
							     collecting i)))
       (has-peers '(:has-peers))
       (sorted-comps-with-combinators-for-peers (let ((comps-with-combinators nil))
						  (maplist (lambda (l) (if (is-peer (car l) (cadr l))
									   (progn
									     (setf (cdddar l) has-peers)
									     (setf comps-with-combinators 
										   (append 
										    (mapcar 
										     (lambda (x) 
										       (list (car l) x))
										     valid-combinators-for-comps-with-peers)
										    comps-with-combinators)))))
							   sorted-comps)
						  (mapcar #'reverse (sort (append (mapcar #'list sorted-comps)
										  comps-with-combinators) 
									  #'integer-comparator)))))

  (defun run-collect (n ulimit)
    "This function generates all the numbers upto ulimit concatenates them removing all the spaces and alphabetically sorts them and returns the sum of all the integers upto the integer containing the nth character and last integer"
    (let ((total-number-of-chars 0) (sum 0) (number-of-integers 0) (last-integer 0) (comp-list nil) (l nil))
      (map-n-permute sorted-comps-with-combinators-for-peers 14 
		     (lambda (x y) (if (< total-number-of-chars n)
				       (if (is-valid x y)
					   (let* ((cmp-lst (reverse (append x y)))
						  (lint (comps-to-integer cmp-lst)))
					     (if (< lint ulimit)
						 (progn 
						   (setf comp-list cmp-lst)
						   (setf last-integer lint)
						   (push last-integer l)
						   (incf sum last-integer)
						   (incf total-number-of-chars 
							 (apply #'+ (mapcar #'caddr comp-list)))
						   (incf number-of-integers))
						 nil))
					   nil)
				       nil)))
      (values (list 'total-number-of-char total-number-of-chars) 
	      (list 'sum sum)
	      (list 'number-of-integers number-of-integers)
	      (list 'last-integer last-integer)
	      (list 'comp-list (mapcar #'car comp-list))))))